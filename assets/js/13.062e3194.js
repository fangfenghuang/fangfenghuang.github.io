(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{338:function(e,s,a){"use strict";a.r(s);var t=a(0),r=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"apiversion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apiversion"}},[e._v("#")]),e._v(" apiVersion")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("kubectl api-versions\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("ul",[s("li",[s("p",[e._v("alpha\n名称中带有alpha的API版本是进入Kubernetes的新功能的早期候选版本。这些可能包含错误，并且不保证将来可以使用。")])]),e._v(" "),s("li",[s("p",[e._v("beta\nAPI版本名称中的beta表示测试已经超过了alpha级别，并且该功能最终将包含在Kubernetes中。 虽然它的工作方式可能会改变，并且对象的定义方式可能会完全改变，但该特征本身很可能以某种形式将其变为Kubernetes。")])]),e._v(" "),s("li",[s("p",[e._v("stable\n稳定的apiVersion这些名称中不包含alpha或beta。 它们可以安全使用。")])]),e._v(" "),s("li",[s("p",[e._v("v1\n这是Kubernetes API的第一个稳定版本。 它包含许多核心对象。")])]),e._v(" "),s("li",[s("p",[e._v("apps/v1\napps是Kubernetes中最常见的API组，其中包含许多核心对象和v1。 它包括与在Kubernetes上运行应用程序相关的功能，如Deployments，RollingUpdates和ReplicaSets。")])]),e._v(" "),s("li",[s("p",[e._v("autoscaling/v1\n此API版本允许根据不同的资源使用指标自动调整容器。此稳定版本仅支持CPU扩展，但未来的alpha和beta版本将允许您根据内存使用情况和自定义指标进行扩展。")])]),e._v(" "),s("li",[s("p",[e._v("batch/v1\nbatchAPI组包含与批处理和类似作业的任务相关的对象（而不是像应用程序一样的任务，如无限期地运行Web服务器）。 这个apiVersion是这些API对象的第一个稳定版本。")])]),e._v(" "),s("li",[s("p",[e._v("batch/v1beta1\nKubernetes中批处理对象的新功能测试版，特别是包括允许您在特定时间或周期运行作业的CronJobs。")])]),e._v(" "),s("li",[s("p",[e._v("certificates.k8s.io/v1beta1\n此API版本添加了验证网络证书的功能，以便在群集中进行安全通信。 您可以在官方文档上阅读更多内容。")])]),e._v(" "),s("li",[s("p",[e._v("extensions/v1beta1\n此版本的API包含许多新的常用Kubernetes功能。 部署，DaemonSets，ReplicaSet和Ingresses都在此版本中收到了重大更改。")])]),e._v(" "),s("li",[s("p",[e._v("policy/v1beta1\n此apiVersion增加了设置pod中断预算和pod安全性新规则的功能")])]),e._v(" "),s("li",[s("p",[e._v("rbac.authorization.k8s.io/v1\n此apiVersion包含Kubernetes基于角色的访问控制的额外功能。这有助于您保护群集")])])]),e._v(" "),s("h2",{attrs:{id:"resourceversion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resourceversion"}},[e._v("#")]),e._v(" resourceVersion")]),e._v(" "),s("p",[e._v("这个版本号是一个 K8s 的内部机制，用户不应该假设它是一个数字或者通过比较两个版本号大小来确定资源对象的新旧，唯一能做的就是通过比较版本号相等来确定对象是否是同一个版本（即是否发生了变化）。而 resourceVersion 一个重要的用处，就是来做 update 请求的版本控制。\nkube-apiserver 会校验用户 update 请求提交对象中的 resourceVersion 一定要和当前 K8s 中这个对象最新的 resourceVersion 一致，才能接受本次 update。否则，K8s 会拒绝请求，并告诉用户发生了版本冲突（Conflict）。")]),e._v(" "),s("h2",{attrs:{id:"patch-机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patch-机制"}},[e._v("#")]),e._v(" Patch 机制")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("json patch\n在 json patch 中我们要指定操作类型，比如 add 新增还是 replace 替换，另外在修改 containers 列表时要通过元素序号来指定容器。")])]),e._v(" "),s("li",[s("p",[e._v("merge patch（默认）\nmerge patch 无法单独更新一个列表中的某个元素，因此不管我们是要在 containers 里新增容器、还是修改已有容器的 image、env 等字段，都要用整个 containers 列表来提交 patch：")])]),e._v(" "),s("li",[s("p",[e._v("strategic merge patch\n在我们 patch 更新 containers 不再需要指定下标序号了，而是指定 name 来修改，K8s 会把 name 作为 key 来计算 merge。\n目前 strategic 策略只能用于原生 K8s 资源以及 Aggregated API 方式的自定义资源，对于 CRD 定义的资源对象，是无法使用的。")])])]),e._v(" "),s("h2",{attrs:{id:"externaltrafficpolicy-跳过snat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#externaltrafficpolicy-跳过snat"}},[e._v("#")]),e._v(" externalTrafficPolicy，跳过SNAT")]),e._v(" "),s("p",[e._v("对于Service, 如果指定类型为 NodePort, 那么这个端口会在集群的所有 Node 上打开，即使这个Node 上面没有这个pod")]),e._v(" "),s("p",[e._v("Kube-proxy转发时会保留源IP。即：容器收到的报文，看到源IP地址还是用户的。")]),e._v(" "),s("p",[e._v("缺点是负载均衡可能不是很好，因为一旦容器实例分布在多个节点上，它只转发给本机，不跨节点转发流量。当然，少了一次转发，性能会相对好一丢丢。")]),e._v(" "),s("p",[e._v("注：这种模式下的Service类型只能为外部流量，即：LoadBalancer 或者 NodePort 两种，否则会报错")]),e._v(" "),s("h2",{attrs:{id:"存储空间资源限制ephemeral-storage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储空间资源限制ephemeral-storage"}},[e._v("#")]),e._v(" 存储空间资源限制ephemeral-storage")]),e._v(" "),s("p",[e._v("在每个Kubernetes的节点上，kubelet的根目录(默认是/var/lib/kubelet)和日志目录(/var/log)保存在节点的主分区上，这个分区同时也会被Pod的EmptyDir类型的volume、容器日志、镜像的层、容器的可写层所占用。")]),e._v(" "),s("div",{staticClass:"language-yaml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("resources")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("requests")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("cpu")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("memory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 2048Mi\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("ephemeral-storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 2Gi\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("limits")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("cpu")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("memory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 2048Mi\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("ephemeral-storage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 5Gi\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("h3",{attrs:{id:"使用限制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用限制"}},[e._v("#")]),e._v(" 使用限制：")]),e._v(" "),s("ul",[s("li",[e._v("只要Root Dir和kubelet --root-dir在一个分区，就能起作用")]),e._v(" "),s("li",[e._v("如果运行时指定了别的独立的分区，比如修改了docker的镜像层和容器可写层的存储位置(默认是/var/lib/docker)所在的分区，将不再将其计入ephemeral-storage的消耗。")])]),e._v(" "),s("h3",{attrs:{id:"效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#效果"}},[e._v("#")]),e._v(" 效果")]),e._v(" "),s("p",[e._v("在容器写入超过存储限制时就会被驱逐掉\nteststorage   0/1       Evicted   0         1m")]),e._v(" "),s("h2",{attrs:{id:"qos-服务质量等级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#qos-服务质量等级"}},[e._v("#")]),e._v(" Qos 服务质量等级")]),e._v(" "),s("p",[e._v("Guaranteed：Pod 里的每个容器都必须有内存/CPU 限制和请求，而且值必须相等。\nBurstable：Pod 里至少有一个容器有内存或者 CPU 请求且不满足 Guarantee 等级的要求，即内存/CPU 的值设置的不同。\nBestEffort：容器必须没有任何内存或者 CPU 的限制或请求。")]),e._v(" "),s("p",[s("strong",[e._v("三个级别的优先级从低到高的顺序是：")]),e._v("\nBestEffort pods -> Burstable pods -> Guaranteed pods")]),e._v(" "),s("p",[s("strong",[e._v("可压缩资源")]),e._v("：如CPU，即使cpu 超配，也可以划分时间片运行，只是运行变慢，进程不会挂。\n"),s("strong",[e._v("不可压缩资源")]),e._v("：Memory/Storage，内存不同于CPU，系统内存不足时，会触发 OOM杀死进程，按照oom score 来确定先kill谁，oom_score_adj值越高，被kill 的优先级越高。")]),e._v(" "),s("h2",{attrs:{id:"resourceversion-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resourceversion-2"}},[e._v("#")]),e._v(" ResourceVersion")]),e._v(" "),s("p",[e._v("绝大部分情况下，apiserver 直接从本地缓存提供服务（因为它缓存了集群全量数据）；\n某些特殊情况，例如，\n客户端明确要求从 etcd 读数据（追求最高的数据准确性）\napiserver 本地缓存还没建好\n对于非结构化的数据存储系统来说，LIST操作通常都是非常重量级的，不仅占用大量的 磁盘 IO、网络带宽和 CPU。K8s的LIST请求大部分都应该被apiserver挡住，从它的本地缓存提供服务，但如果使用不当，就会跳过缓存直接到达 etcd，有很大的稳定性风险。")]),e._v(" "),s("p",[e._v("Get请求：GetOptions{}与ListOption{}一样，不设置ResourceVersion=0会导致 apiserver去etcd拿数据，应该尽量避免。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. \nWhen specified for list: \n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("ul",[s("li",[e._v("if unset, then the result is returned from remote storage based on quorum-read flag;")]),e._v(" "),s("li",[e._v("if it's 0, then we simply return what we currently have in cache, no guarantee;")]),e._v(" "),s("li",[e._v("if set to non zero, then the result is at least as fresh as given rv.\n未指定ResourceVersion，获取最新数据；ApiServer收到这个类型的读请求后，会向Etcd发出线性读请求获取etcd最新数据\nResourceVersion=“0”,获取ApiServer的缓存数据，有可能是过期数据。\nResouceVersion为非0的字符串，获取不小于该version的数据。\n默认是未指定ResouceVersion。\n如果客户端没传ListOption，则初始化一个默认值，其中的ResourceVersion设置为空字符串， 这将使apiserver从etcd拉取数据来返回给客户端，而不使用本地缓存（除非本地缓存还没有建好）。\nresourceVersion=0将导致limit被忽略，也就是说， 虽然指定了limit，但请求会返回全量数据。\n从 v1.19 版本开始，Kubernetes API 服务器支持 list 请求的 resourceVersionMatch 参数")])]),e._v(" "),s("h3",{attrs:{id:"调优建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调优建议"}},[e._v("#")]),e._v(" 调优建议")]),e._v(" "),s("p",[e._v("List 请求默认设置 ResourceVersion=0\n优先使用 namespaced API\n通过label/field selector做过滤")]),e._v(" "),s("p",[e._v("http://arthurchiao.art/blog/k8s-reliability-list-data-zh\nhttps://www.pudn.com/news/62c14ac49f2d63494a8b7887.html\nhttps://kubernetes.io/zh-cn/docs/reference/_print/")]),e._v(" "),s("h2",{attrs:{id:"主机网络hostnetwork"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主机网络hostnetwork"}},[e._v("#")]),e._v(" 主机网络hostNetwork")]),e._v(" "),s("ul",[s("li",[e._v("Pod使用主机网络只需要在配置中添加hostNetwork: true即可")]),e._v(" "),s("li",[e._v("部署后可以看到Pod的IP与节点的IP相同，说明Pod直接使用了主机网络。")]),e._v(" "),s("li",[e._v("Pod直接使用主机的网络会占用宿主机的端口，Pod的IP就是宿主机的IP，使用时需要考虑是否与主机上的端口冲突")]),e._v(" "),s("li",[e._v("由于占用主机端口，使用Deployment部署hostNetwork类型Pod时，要注意Pod的副本数不要超过节点数量，否则会导致一个节点上调度了多个Pod，Pod启动时端口冲突无法创建")])]),e._v(" "),s("h2",{attrs:{id:"pod的重启策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pod的重启策略"}},[e._v("#")]),e._v(" pod的重启策略")]),e._v(" "),s("p",[e._v("Always：但凡pod对象终止就重启，此为默认策略。")]),e._v(" "),s("p",[e._v("OnFailure：仅在pod对象出现错误时才重启")]),e._v(" "),s("h2",{attrs:{id:"删除一个pod会发生什么事情"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除一个pod会发生什么事情"}},[e._v("#")]),e._v(" 删除一个Pod会发生什么事情？")]),e._v(" "),s("p",[e._v("Kube-apiserver会接受到用户的删除指令，默认有30秒时间等待优雅退出，超过30秒会被标记为死亡状态，此时Pod的状态Terminating，kubelet看到pod标记为Terminating就开始了关闭Pod的工作；")]),e._v(" "),s("p",[e._v("关闭流程如下：\n1、 pod从service的endpoint列表中被移除；\n2、 如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程；\n3、 进程被发送TERM信号（kill -14）\n4、 当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。")]),e._v(" "),s("h2",{attrs:{id:"镜像拉取策略-imagepullpolicy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#镜像拉取策略-imagepullpolicy"}},[e._v("#")]),e._v(" 镜像拉取策略 ImagePullPolicy")]),e._v(" "),s("p",[e._v("Always：不管镜像是否存在都会进行一次拉取\nNever：不管镜像是否存在都不会进行拉取\nIfNotPresent：只有镜像不存在时，才会进行镜像拉取")]),e._v(" "),s("h2",{attrs:{id:"为容器配置hosts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为容器配置hosts"}},[e._v("#")]),e._v(" 为容器配置hosts")]),e._v(" "),s("h1",{attrs:{id:"配置在二级ipsec下-和cointariners同级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置在二级ipsec下-和cointariners同级"}},[e._v("#")]),e._v(" 配置在二级ipsec下，和cointariners同级")]),e._v(" "),s("div",{staticClass:"language-yaml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("...")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("hostAliases")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("ip")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"172.16.0.12"')]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("hostnames")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"api.cc.pro"')]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("containers")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" cc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("x\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("h2",{attrs:{id:"容器修改hostname"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器修改hostname"}},[e._v("#")]),e._v(" 容器修改hostname")]),e._v(" "),s("div",{staticClass:"language-yaml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("hostname")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" busybox"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("subdomain")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" busybox"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("subdomain\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("因为pod的访问域名是hostname.custom-subdomain.default.svc.cluster.local")]),e._v(" "),s("p",[e._v("所以该 Pod 的域名是 busybox-1.busybox-subdomain.default.svc.cluster.local。")]),e._v(" "),s("h2",{attrs:{id:"kubernetes-指定节点nodename与nodeselector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-指定节点nodename与nodeselector"}},[e._v("#")]),e._v(" kubernetes 指定节点nodeName与NodeSelector")]),e._v(" "),s("p",[e._v("Pod.spec.nodeName用于强制约束将Pod调度到指定的Node节点上，这里说是“调度”，但其实指定了nodeName的Pod会直接跳过Scheduler的调度逻辑，直接写入PodList列表，该匹配规则是强制匹配。\nPod.spec.nodeSelector是通过kubernetes的label-selector机制进行节点选择，由scheduler调度策略MatchNodeSelector进行label匹配，调度pod到目标节点，该匹配规则是强制约束。启用节点选择器的步骤为：Node添加label标记>Pod定义中添加nodeSelector")]),e._v(" "),s("h2",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])])])}),[],!1,null,null,null);s.default=r.exports}}]);